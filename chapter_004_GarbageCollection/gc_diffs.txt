Для тестирования использовался jconsole.
Наблюдения следующие:
При слабых мощностях Serial работает лучше всех (и при этом не умирает с OutOfMemory), связано это с тем, что более
продвинутые GC дружат с дефрагментацией tenure. ParallelGc - дробит под каждый поток, CMS не занимается уплотнением
tenured после очистки, G1 - вообще дробит весь heap.
Но, при мощностях, которые превышают потребление ситуация примерно следующая.
STW(Если "GC time" в окошке Details это и есть STW) для Xmx:100m: Время 5 минут.
Serial: 0.080 s
Parallel: 0.088 s
CMS: 0.120 s
G1:  0.050 s

CMS за счёт своих постоянных проверок маркировок сильно снижает ропускную способность (что и заявлено в описании).
А G1 за счет того, что он для своего множества раздела смог выделить достаточно большой объем и благодаря тому, что у нас
больших объектов нет, а маленьких объектов много - выигрывает в проивзодительности.
Следует брать в расчёт, что это время только для youngGen, так как tenured за время тестов не переполнился.

Эксперимент с OutOfMemory:
При эксперементе с Xmx10m первый OutOfMemory вылетел на ~ 8.8 / 10 использования памяти, но при этом quartz продолжил работу
до момента, когда память стала ~9.6/10 с выбросом второго OutOfMemory уже фатального.
Проще всего было "сломать" G1, он упал почти сразу, так как для него все объекты стали сразу Humongous и сразу же попадали в Tenured,
где и вызывали переполнение. Другие GC ещё как-то пытались перетаскивать отдельные объекты по Eden-survives, но тоже в скором времени упали.